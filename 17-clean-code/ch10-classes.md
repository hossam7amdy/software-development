# Chapter 10

Focuses on writing clean classes, emphasizing that this is a higher level of code organization that is crucial for clean code.

**Key principles and practices discussed in this chapter include:**

- **Class Organization**: Following standard Java conventions, classes should list variables first, starting with public static constants, then private static variables, and finally private instance variables. Public functions should follow the variables, with private utilities called by a public function placed immediately after it to follow the stepdown rule.
- **Encapsulation**: While keeping variables and utility functions private is preferred, the authors are pragmatic and will make them protected or package scope if a test in the same package needs access. However, this loosening of encapsulation is a last resort.
- **Classes Should Be Small!**: Similar to functions, the primary rule for classes is that they should be small, and even smaller than that. Instead of physical lines, the size of a class is measured by its **responsibilities**.
- **The Single Responsibility Principle (SRP)**: **A class should have one, and only one, reason to change**. This principle also serves as a guideline for class size; if a class cannot be described concisely or its name is ambiguous (e.g., containing weasel words like "Processor" or "Manager"), it likely has too many responsibilities. The SRP encourages creating better abstractions and recognizing responsibilities. Fear of having many small classes is addressed by stating that such systems have no more moving parts but are better organized, allowing developers to understand only the directly affected complexity. The goal is systems composed of many small classes, each with a single responsibility and collaborating with others.
- **Cohesion**: Classes should have a small number of instance variables, and each method should manipulate one or more of these variables. High cohesion means the methods and variables are co-dependent and form a logical whole. Breaking down large functions into smaller ones often leads to the opportunity to split out several smaller, more cohesive classes.
- **Maintaining Cohesion Results in Many Small Classes**: High cohesion often leads to many small classes with focused responsibilities.
- **Organizing for Change**: Clean systems are organized to reduce the risk of change. Modifying an "open" class (one that needs to be altered to add new functionality) introduces risk. A better approach is to "close" classes against modification and extend their behavior through inheritance or other mechanisms.
- **Isolating from Change**: An example shows refactoring a single `Sql` class into a set of closed classes, each responsible for a specific SQL operation (e.g., `CreateSql`, `SelectSql`). Common private behavior is isolated in utility classes. This design makes the code simpler, reduces the risk of breaking existing functionality, and makes testing easier. Another example illustrates using interfaces and dependency injection to isolate a `Portfolio` class from a concrete `StockExchange` implementation, allowing for easier testing with a testable implementation.

In essence, Chapter 10 advocates for creating small, cohesive classes with a single responsibility to make systems easier to understand, maintain, and less prone to the risks associated with change.
